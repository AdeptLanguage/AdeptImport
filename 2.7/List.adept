
#default List_bounds_checks true
#default List_error_with_type true
#default List_ownership_checks true
#default List_disable_safety false

#if List_disable_safety
    #set List_bounds_checks false
    #set List_ownership_checks false
#end

#if List_ownership_checks
    func assertOwnership(this *<$T> List, verb *ubyte) {
        if this.ownership != Ownership::OWN && !(this.ownership == Ownership::REFERENCE && this.items == null) {
            fprintf(stderr, '<%s> List Error: Cannot %s list that doesn\'t have ownership\n', typenameof $T)
            abort()
        }
    }
#end

#if List_bounds_checks
    func assertBounds(this *<$T> List, index usize, operation *ubyte) {
        if index < 0 || index >= this.length {
            fprintf(stderr, '<%s> List Error: %s index out of range\n', operation, typenameof $T)
            abort()
        }
    }
#end

import 'sys/cstdio.adept'
import 'sys/cstdlib.adept'
import 'sys/cstring.adept'

import InitializerList

struct <$T> List (items *$T, length, capacity usize, ownership Ownership) {
    func __defer__ {
        if this.ownership == Ownership::OWN || this.ownership == Ownership::GIVEN {
            each $T in static [this.items, this.length], it.?__defer__()
            delete this.items
        }
    }

    func __assign__(other POD <$T> List) {
        this.__defer__()
        
        *this = POD List(
            other.items,
            other.length,
            other.capacity,
            other.ownership == Ownership::GIVEN ? Ownership::OWN : Ownership::REFERENCE
        )
    }

    func __array__() *$T {
        return this.items
    }

    func __length__() usize {
        return this.length
    }

    func __access__(index usize) *$T {
        #if List_bounds_checks
            this.assertBounds(index, '[]')
        #end
        
        return this.items at index
    }

    func commit() <$T> List {
        if this.ownership == Ownership::OWN {
            this.ownership = Ownership::REFERENCE
            return List(this.items, this.length, this.capacity, Ownership::GIVEN)
        } else {
            return *this
        }
    }

    func donate() <$T> List {
        if this.ownership == Ownership::OWN {
            this.ownership = Ownership::DONOR
            return List(this.items, this.length, this.capacity, Ownership::GIVEN)
        } else {
            return *this
        }
    }


    func add() *$T {
        #if List_ownership_checks
            this.assertOwnership('add() to')
        #end
        
        if this.items == null {
            this.items = malloc(sizeof $T * 4)
            this.length = 0
            this.capacity = 4
            this.ownership = Ownership::OWN
        } else if this.length == this.capacity {
            this.capacity *= 2
            resized *$T = malloc(sizeof $T * this.capacity)
            memcpy(resized, this.items, sizeof $T * this.length)
            delete this.items
            this.items = resized
        }
        
        added *$T = this.items at this.length++
        memset(added, 0, sizeof $T)
        return added
    }

    func add(item POD $~T) {
        added *$T = this.add()

        if added != null {
            *added = item
        }
    }

    func insert(index usize) *$T {
        if this.add() {
            inserted *$T = this.items at index
            memmove(this.items at (index + 1), inserted, (this.length - index - 1) * sizeof $T)
            memset(inserted, 0, sizeof $T)
            return inserted
        } else {
            return null
        }
    }

    func insert(index usize, item POD $~T) {
        inserted_item *$T = this.insert(index)

        if inserted_item != null {
            *inserted_item = item
        }
    }

    func prepend(item POD $~T) {
        if this.add() != null {
            memmove(this.items at 1, this.items, sizeof $T * (this.length - 1))
            memset(this.items, 0, sizeof $T)
            this.items[0] = item
        }
    }

    func remove(index usize) {
        #if List_ownership_checks
            this.assertOwnership('remove() from')
        #end

        #if List_bounds_checks
            this.assertBounds(index, 'remove')
        #end
        
        this.length -= 1
        this.items[index].?__defer__()
        memmove(this.items at index, this.items at (index + 1), (this.length - index) * sizeof $T)
    }

    func reserve(count usize) {
        #if List_ownership_checks
            this.assertOwnership('reserve() space for')
        #end
        
        if this.items == null {
            *this = POD List(malloc(sizeof $T * count), 0, count, Ownership::OWN)
        } else if this.capacity < count {
            resized *$T = memcpy(malloc(sizeof $T * count), this.items, sizeof $T * this.length)
            delete this.items
            this.items = resized
            this.capacity = count
            this.ownership = Ownership::OWN
        }
    }

    func get(index usize) $T {
        #if List_bounds_checks
            this.assertBounds(index, 'get()')
        #end
        
        return this.items[index]
    }

    func getPointer(index usize) *$T {
        #if List_bounds_checks
            this.assertBounds(index, 'getPointer()')
        #end
        
        return this.items at index
    }

    func clear() {
        if this.ownership == Ownership::OWN || this.ownership == Ownership::GIVEN {
            each $T in static [this.items, this.length], it.?__defer__()
            this.length = 0
        } else {
            memset(this, 0, sizeof <$T> List)
        }
    }

    func empty() bool {
        return this.length == 0
    }
}

func List(items *$T, length usize, ownership Ownership = Ownership::REFERENCE) <$T> List {
    list POD <$T> List
    list.items = items
    list.length = length
    list.capacity = length
    list.ownership = ownership
    return list
}

func List(items *$T, length, capacity usize, ownership Ownership = Ownership::REFERENCE) <$T> List {
    list POD <$T> List
    list.items = items
    list.length = length
    list.capacity = capacity
    list.ownership = ownership
    return list
}

func __pass__(list POD <$T> List) <$T> List {
    if list.ownership == Ownership::OWN {
        list.ownership = Ownership::REFERENCE
    } else if list.ownership == Ownership::GIVEN {
        list.ownership = Ownership::OWN    
    }

    return list
}

func reverse(this *<$T> List) void {
    #if List_ownership_checks
        this.assertOwnership('reverse()')
    #end

    repeat this.length / 2 {
        preserved POD $T = this.items[idx]
        this.items[idx] = this.items[this.length - idx - 1]
        this.items[this.length - idx - 1] = POD preserved
    }
}

func reduce(this *<$T> List) void {
    #if List_ownership_checks
        this.assertOwnership('reduce()')
    #end

    if this.length > 0, this.remove(this.length - 1)
}

func reduce(this *<$T> List, amount usize) void {
    #if List_ownership_checks
        this.assertOwnership('reduce()')
    #end

    repeat static amount {
        if this.length == 0 {
            break
        }

        this.remove(this.length - 1)
    }
}

func first(this *<$T> List) *$T {
    return this.length ? this.items : null
}

func last(this *<$T> List) *$T {
    return this.length ? this.items at (this.length - 1) : null
}

func contains(this *<$T> List, value $~T) bool {
    each $T in static *this, if it == value, return true
    return false
}

func map(this *<$T> List, function func($~T) $S) <$S> List {
    items *$T = calloc(this.length, sizeof $S)

    each $T in static *this {
        items[idx] = function(&it)
    }

    return List(items, this.length, this.length, Ownership::GIVEN)
}

func map(this *<$T> List, function func(*$T) $S) <$S> List {
    items *$T = calloc(this.length, sizeof $S)

    each $T in static *this {
        items[idx] = function(&it)
    }

    return List(items, this.length, this.length, Ownership::GIVEN)
}

implicit func __as__(initializer <$T> InitializerList) <$T> List {
    return List(initializer.array, initializer.length, Ownership::REFERENCE)
}

// Allow <long> InitializerList for <int> List
implicit func __as__(initializer <long> InitializerList) <int> List = initializer as <int> InitializerList as <int> List

// Allow <double> InitializerList for <float> List
implicit func __as__(initializer <double> InitializerList) <float> List = initializer as <float> InitializerList as <float> List
