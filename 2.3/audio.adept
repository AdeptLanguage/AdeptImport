
// NOTE: This is only an experimental prototype based on earlier
// projects and should not be relied upon
pragma deprecated 'Audio API is experimental'

#default audio_print_errors true

import 'sys/cstdio.adept'
import 'sys/cstdlib.adept'
import 'alut/alut.adept'
import 'openal/openal.adept'

func audioInit() void {
    zeros *float = static float {0.0f, 0.0f, 0.0f}
    orientation *float = static float {0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f}
    alutInit(null, null)
    alListenerfv(AL_POSITION, zeros)
    alListenerfv(AL_VELOCITY, zeros)
    alListenerfv(AL_ORIENTATION, orientation)
    alGetError()
}

func audioTerminate() void {
    alutExit()
}

struct Sound (buffer_id uint, loop bool, volume float) {
    func load(filename *ubyte, looping bool, volume float) successful {
        if this.buffer_id != AL_NONE, return false
        this.buffer_id = alutCreateBufferFromFile(filename)
        
        if alGetError() != AL_NO_ERROR || alutGetError() != ALUT_ERROR_NO_ERROR {
            #if audio_print_errors
            printf('Error failed to load sound "%s"\n', filename)
            #end
            return false
        }
        
        this.loop = looping
        this.volume = volume
        return true
    }
    
    func create {
        if this.buffer_id != AL_NONE, return
        alGenBuffers(1, &this.buffer_id)
    }

    func create(buffer_id uint) {
        if this.buffer_id != AL_NONE, this.destroy()
        this.buffer_id = buffer_id
    }

    func destroy {
        alDeleteBuffers(1, &this.buffer_id)
    }
}

struct SoundPlayer (source_id uint, volume float) {
    func create successful {
        zeros *float = static float {0.0f, 0.0f, 0.0f}

        alGenSources(1, &this.source_id)
        alSourcefv(this.source_id, AL_POSITION, zeros)
        alSourcefv(this.source_id, AL_VELOCITY, zeros)

        if alGetError() != AL_NO_ERROR {
            #if audio_print_errors
            puts('Failed to create audio source')
            #end
            return false
        }

        return true
    }

    func bindSound(sound Sound) {
        alSourcei(this.source_id, AL_LOOPING, sound.loop as uint)
        alSourcei(this.source_id, AL_BUFFER, sound.buffer_id)
        alSourcef(this.source_id, AL_PITCH, 1.0f)
        alSourcef(this.source_id, AL_GAIN, sound.volume)
        this.volume = sound.volume
    }

    func play {
        alSourcePlay(this.source_id)
    }

    func play(sound Sound) {
        this.bindSound(sound)
        alSourcePlay(this.source_id)
    }

    func stop {
        alSourceStop(this.source_id)
    }

    func isPlaying bool {
        state int = undef
        alGetSourcei(this.source_id, AL_SOURCE_STATE, &state)
        return state == AL_PLAYING
    }

    func setVolume(new_volume_multiplier float) {
        alSourcef(this.source_id, AL_GAIN, this.volume * new_volume_multiplier)
    }

    func setVolumeRaw(new_volume float) {
        alSourcef(this.source_id, AL_GAIN, new_volume)
    }

    func destroy {
        alDeleteSources(1, &this.source_id)
    }
}

struct SoundMixer (player SoundPlayer, volume float) {

}

struct PlayableSound (sound Sound, player SoundPlayer) {
    func load(filename *ubyte, looping bool, volume float) {
        this.sound.load(filename, looping, volume)
        this.player.create()
        this.player.bindSound(this.sound)
    }

    func play {
        alSourcePlay(this.player.source_id)
    }

    func stop {
        alSourceStop(this.player.source_id)
    }

    func isPlaying bool = this.player.isPlaying()

    func destroy {
        this.player.destroy()
        this.sound.destroy()
    }
}
